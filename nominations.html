<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LTA County Leagues Nominations Checker</title>
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- SheetJS (xlsx) library for reading Excel files -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <style>
        /* A little extra style for the file input button */
        .file-input-button {
            background: linear-gradient(145deg, #5c67f2, #737eff);
            transition: all 0.3s ease;
        }
        .file-input-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }
        /*
         * Explicitly define the spin animation to ensure it works.
         * The 'animate-spin' class from Tailwind will use this.
         */
        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }
        .animate-spin {
            animation: spin 1s linear infinite;
        }
    </style>
</head>
<body class="bg-gray-100 flex items-center justify-center min-h-screen font-sans">

    <div class="bg-white rounded-xl shadow-lg p-8 w-full max-w-6xl mx-4">

        <div class="text-center mb-8">
            <h1 class="text-3xl font-bold text-gray-800">LTA County Leagues Nominations Checker</h1>
            <p class="text-gray-600 mt-2">
                Choose an output file from Tournament Software (.xlsx) to examine its contents below.
                This data is not stored or uploaded to a server.
            </p>
        </div>

        <!-- File Input Form -->
        <div class="flex items-center justify-center gap-8">
            <!-- Matches File Input -->
            <div class="flex items-center gap-2">
                <label for="matches-file-upload" class="file-input-button text-white font-bold py-3 px-6 rounded-lg cursor-pointer flex items-center justify-center">
                    <span>Choose Matches File</span>
                </label>
                <input id="matches-file-upload" type="file" class="hidden" accept=".xlsx, application/vnd.openxmlformats-officedocument.spreadsheetml.sheet">
                <svg id="matches-tick" class="h-6 w-6 text-green-500 hidden" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7" />
                </svg>
            </div>
            <!-- Nominations File Input -->
            <div class="flex items-center gap-2">
                <label for="nominations-file-upload" class="file-input-button text-white font-bold py-3 px-6 rounded-lg cursor-pointer flex items-center justify-center">
                    <span>Choose Nominations File</span>
                </label>
                <input id="nominations-file-upload" type="file" class="hidden" accept=".xlsx, application/vnd.openxmlformats-officedocument.spreadsheetml.sheet">
                 <svg id="nominations-tick" class="h-6 w-6 text-green-500 hidden" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7" />
                </svg>
            </div>
            <!-- Skip Nominations Button -->
             <div class="flex items-center gap-2">
                 <button id="skip-nominations-button" class="bg-gray-200 text-gray-700 font-bold py-3 px-6 rounded-lg hover:bg-gray-300">
                    Skip Nominations File
                </button>
            </div>
        </div>

        <!-- Reuse Cached Files Button -->
        <div class="text-center mt-4">
             <button id="reuse-files-button" class="text-sm text-blue-600 hover:underline hidden">
                Reuse most recently uploaded files
            </button>
        </div>

        <!-- Main Loading Indicator -->
        <div id="main-loader" class="flex items-center justify-center mt-6 hidden">
             <svg class="animate-spin -ml-1 mr-3 h-5 w-5 text-gray-700" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
            </svg>
            <span class="text-gray-700 font-semibold">Loading...</span>
        </div>

        <!-- Div where the resulting HTML table will be displayed -->
        <div id="output" class="mt-8">
             <p class="text-center text-gray-500">Please select both a matches file and a nominations file, or skip the nominations file.</p>
        </div>

    </div>

    <script>
        // --- DOM Element References ---
        const matchesFileUpload = document.getElementById('matches-file-upload');
        const nominationsFileUpload = document.getElementById('nominations-file-upload');
        const skipNominationsButton = document.getElementById('skip-nominations-button');
        const matchesTick = document.getElementById('matches-tick');
        const nominationsTick = document.getElementById('nominations-tick');
        const mainLoader = document.getElementById('main-loader');
        const outputDiv = document.getElementById('output');
        const reuseFilesButton = document.getElementById('reuse-files-button');

        // --- State Management ---
        let matchesFile = null;
        let nominationsFile = null;

        // --- Event Listeners ---
        matchesFileUpload.addEventListener('change', (e) => {
            matchesFile = e.target.files[0];
            matchesTick.classList.toggle('hidden', !matchesFile);
            if (matchesFile && nominationsFile) tryToProcessFiles();
        });

        nominationsFileUpload.addEventListener('change', (e) => {
            nominationsFile = e.target.files[0];
            nominationsTick.classList.toggle('hidden', !nominationsFile);
            if (matchesFile && nominationsFile) tryToProcessFiles();
        });

        skipNominationsButton.addEventListener('click', () => {
             if (!matchesFile) {
                alert("Please choose a Matches File first.");
                return;
            }
            tryToProcessFiles(true); // Pass true to indicate skipping nominations
        });

        reuseFilesButton.addEventListener('click', () => {
            const lastMatchesData = localStorage.getItem('lastMatchesFile');
            const lastNominationsData = localStorage.getItem('lastNominationsFile');
            if (lastMatchesData && lastNominationsData) {
                processAllData(lastMatchesData, lastNominationsData);
            }
        });

        // --- On Page Load ---
        document.addEventListener('DOMContentLoaded', () => {
            const lastMatchesName = localStorage.getItem('lastMatchesFileName');
            const lastNominationsName = localStorage.getItem('lastNominationsFileName');
            if (lastMatchesName && lastNominationsName) {
                reuseFilesButton.textContent = `Reuse most recently uploaded files (${lastMatchesName} and ${lastNominationsName})`;
                reuseFilesButton.classList.remove('hidden');
            }
        });


        /**
         * Toggles the main loading indicator visibility.
         * @param {boolean} isLoading True to show spinner, false to hide.
         */
        function setMainLoading(isLoading) {
            mainLoader.classList.toggle('hidden', !isLoading);
        }

        /**
         * Promisified FileReader to read a file as a Data URL (base64).
         * @param {File} file The file to read.
         * @returns {Promise<string>} A promise that resolves with the file's data URL.
         */
        function readFileAsDataURL(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (event) => resolve(event.target.result);
                reader.onerror = (error) => reject(error);
                reader.readAsDataURL(file);
            });
        }

        /**
         * Core processing function.
         * @param {string} matchesDataURL The base64 data URL for the matches file.
         * @param {string} nominationsDataURL The base64 data URL for the nominations file (can be empty).
         */
        function processAllData(matchesDataURL, nominationsDataURL) {
            setMainLoading(true);
            try {
                // Decode base64 and process matches data
                const matchesData = atob(matchesDataURL.substring(matchesDataURL.indexOf(',') + 1));
                const matchesWorkbook = XLSX.read(matchesData, { type: 'binary' });
                const matchesSheetName = matchesWorkbook.SheetNames[0];
                const matchesWorksheet = matchesWorkbook.Sheets[matchesSheetName];
                const matchesJsonData = XLSX.utils.sheet_to_json(matchesWorksheet, { header: 1 });
                const playerFixtures = processPlayerFixtures(matchesJsonData);

                // Decode base64 and process nominations data (if it exists)
                const nominationsDataString = nominationsDataURL.substring(nominationsDataURL.indexOf(',') + 1);
                let nominationsMap = {};
                if (nominationsDataString) {
                    const nominationsData = atob(nominationsDataString);
                    const nominationsWorkbook = XLSX.read(nominationsData, { type: 'binary' });
                    const nominationsSheetName = nominationsWorkbook.SheetNames[0];
                    const nominationsWorksheet = nominationsWorkbook.Sheets[nominationsSheetName];
                    const nominationsJsonData = XLSX.utils.sheet_to_json(nominationsWorksheet, { header: 1 });
                    nominationsMap = createNominationsMap(nominationsJsonData);
                }

                // Generate and display tables
                const playerSummaryTables = createPlayerSummaryTables(playerFixtures, nominationsMap);
                outputDiv.innerHTML = playerSummaryTables;

            } catch (err) {
                console.error("Error processing files: ", err);
                outputDiv.innerHTML = `<p class="text-center text-red-500">Error processing a file. It might not be a valid XLSX file. Check console for details.</p>`;
            } finally {
                setMainLoading(false);
            }
        }

        /**
         * Reads the selected files, caches them, and starts processing.
         * @param {boolean} skipNominations - True if the user clicked the skip button.
         */
        function tryToProcessFiles(skipNominations = false) {
            setMainLoading(true);

            const promises = [readFileAsDataURL(matchesFile)];
            if (!skipNominations) {
                promises.push(readFileAsDataURL(nominationsFile));
            }

            Promise.all(promises)
                .then(([matchesDataURL, nominationsDataURL]) => {
                    const nomsFile = skipNominations ? {name: '[SKIPPED]'} : nominationsFile;
                    const nomsData = nominationsDataURL || 'data:,'; // Provide empty data URL if skipped

                    localStorage.setItem('lastMatchesFile', matchesDataURL);
                    localStorage.setItem('lastNominationsFile', nomsData);
                    localStorage.setItem('lastMatchesFileName', matchesFile.name);
                    localStorage.setItem('lastNominationsFileName', nomsFile.name);

                    reuseFilesButton.textContent = `Reuse most recently uploaded files (${matchesFile.name} and ${nomsFile.name})`;
                    reuseFilesButton.classList.remove('hidden');

                    processAllData(matchesDataURL, nomsData);
                })
                .catch(err => {
                    console.error("Error reading files: ", err);
                    outputDiv.innerHTML = `<p class="text-center text-red-500">Error reading a file. Please check the console.</p>`;
                    setMainLoading(false);
                });
        }

        function createNominationsMap(jsonData) {
            const map = {};
            if (!jsonData || jsonData.length < 2) return map;

            const headerRow = jsonData[0];
            const teamIndex = headerRow.indexOf("Team");
            const nom1Index = headerRow.indexOf("Nomination 1");
            const nom2Index = headerRow.indexOf("Nomination 2");
            const nom3Index = headerRow.indexOf("Nomination 3");
            const nom4Index = headerRow.indexOf("Nomination 4");

            if ([teamIndex, nom1Index, nom2Index, nom3Index, nom4Index].some(index => index === -1)) {
                console.warn("One or more required columns ('Team', 'Nomination 1-4') not found in nominations file.");
                return map;
            }

            for (let i = 1; i < jsonData.length; i++) {
                const row = jsonData[i];
                const teamName = row[teamIndex];
                const nom1 = row[nom1Index];
                const nom2 = row[nom2Index];
                const nom3 = row[nom3Index];
                const nom4 = row[nom4Index];

                if (teamName && nom1 && nom2 && nom3 && nom4) {
                    map[nom1] = teamName;
                    map[nom2] = teamName;
                    map[nom3] = teamName;
                    map[nom4] = teamName;
                }
            }
            return map;
        }

        function getTeamRank(teamName) {
            if (typeof teamName !== 'string') return Infinity;
            const match = teamName.match(/\d+$/);
            return match ? parseInt(match[0], 10) : Infinity;
        }

        function formatFixtureDate(date) {
            const day = date.getUTCDate();
            const weekday = date.toLocaleDateString('en-US', { weekday: 'long', timeZone: 'UTC' });
            const month = date.toLocaleDateString('en-US', { month: 'long', timeZone: 'UTC' });
            const year = date.getUTCFullYear();
            function getDaySuffix(d) {
                if (d > 3 && d < 21) return 'th';
                switch (d % 10) { case 1: return "st"; case 2: return "nd"; case 3: return "rd"; default: return "th"; }
            }
            return `${weekday} ${day}${getDaySuffix(day)} ${month} ${year}`;
        }

        function processPlayerFixtures(jsonData) {
            const headerRow = jsonData[0] || [];
            const headerMap = {};
            headerRow.forEach((header, index) => { headerMap[header] = index; });

            const playerFixturesTemp = {};
            for (let i = 1; i < jsonData.length; i++) {
                const row = jsonData[i];
                const division = row[headerMap["Division"]];
                const homeTeam = row[headerMap["HomeTeamName"]];
                const awayTeam = row[headerMap["AwayTeamName"]];
                let matchDateNum = row[headerMap["MatchDate"]];
                let matchDate = (typeof matchDateNum === 'number' && matchDateNum > 1)
                    ? new Date(Date.UTC(1899, 11, 30 + matchDateNum))
                    : new Date(matchDateNum);
                if (isNaN(matchDate.getTime()) || !division || !homeTeam || !awayTeam) continue;
                const fixtureKey = `${matchDate.toISOString().split('T')[0]}|${division}|${homeTeam}|${awayTeam}`;
                const playerSlots = [
                    { team: homeTeam, id: row[headerMap["HomeTeamPlayer1_Memberid"]] },
                    { team: homeTeam, id: row[headerMap["HomeTeamPlayer2_Memberid"]] },
                    { team: awayTeam, id: row[headerMap["AwayTeamPlayer1_Memberid"]] },
                    { team: awayTeam, id: row[headerMap["AwayTeamPlayer2_Memberid"]] }
                ];
                playerSlots.forEach(slot => {
                    if (slot.id != null && slot.id !== '') {
                        if (!playerFixturesTemp[slot.id]) playerFixturesTemp[slot.id] = {};
                        playerFixturesTemp[slot.id][fixtureKey] = { date: matchDate, team: slot.team };
                    }
                });
            }
            const playerFixturesFinal = {};
            for (const memberId in playerFixturesTemp) {
                const fixtures = Object.values(playerFixturesTemp[memberId]);
                fixtures.sort((a, b) => a.date - b.date);
                playerFixturesFinal[memberId] = fixtures;
            }
            return playerFixturesFinal;
        }

        function getPlayerProblemStatus(memberId, playerFixtures, nominationsMap, defaultNominationDetails) {
            const fixtures = playerFixtures[memberId] || [];
            const result = { isOverallProblematic: false, problematicFixtures: Array(fixtures.length).fill(false) };
            if (!fixtures.length) return result;

            const nominatedTeam = nominationsMap[memberId];
            const defaultNom = defaultNominationDetails[memberId];

            let nominationRank = getTeamRank(nominatedTeam);
            if (nominationRank === Infinity) {
                nominationRank = defaultNom ? getTeamRank(defaultNom.team) : Infinity;
            }

            if (nominationRank === Infinity) return result;

            let playedUpCount = 0;
            for (let i = 0; i < fixtures.length; i++) {
                const currentRank = getTeamRank(fixtures[i].team);
                let isThisFixtureProblematic = false;

                if (currentRank > nominationRank) isThisFixtureProblematic = true;
                if (playedUpCount >= 3 && currentRank >= nominationRank) isThisFixtureProblematic = true;

                if (isThisFixtureProblematic) {
                    result.problematicFixtures[i] = true;
                    result.isOverallProblematic = true;
                }

                if (currentRank < nominationRank) playedUpCount++;
            }

            return result;
        }

        function createPlayerSummaryTables(playerFixtures, nominationsMap) {
            const memberIds = Object.keys(playerFixtures).sort((a, b) => a - b);
            if (memberIds.length === 0) return '<h2 class="text-2xl font-semibold text-gray-700 mb-4">No Player Fixture Data Found</h2>';

            const explicitlyNominatedTeams = new Set(Object.values(nominationsMap));
            const teamEarliestDates = {};
            Object.values(playerFixtures).flat().forEach(fixture => {
                const team = fixture.team;
                if (!explicitlyNominatedTeams.has(team)) {
                    if (!teamEarliestDates[team] || fixture.date < teamEarliestDates[team]) {
                        teamEarliestDates[team] = fixture.date;
                    }
                }
            });
            const defaultNominationDetails = {};
            Object.keys(teamEarliestDates).forEach(team => {
                const earliestDate = teamEarliestDates[team];
                Object.entries(playerFixtures).forEach(([memberId, fixtures]) => {
                    if (!nominationsMap[memberId]) {
                        const firstMatchForTeam = fixtures.find(f => f.team === team && f.date.getTime() === earliestDate.getTime());
                        if (firstMatchForTeam && !defaultNominationDetails[memberId]) {
                            defaultNominationDetails[memberId] = { team: firstMatchForTeam.team, date: firstMatchForTeam.date };
                        }
                    }
                });
            });

            const playedDownIds = [], playedUpOnlyIds = [], loyalIds = [];
            memberIds.forEach(id => {
                const fixtures = playerFixtures[id];
                if (fixtures.length <= 1 || fixtures.every(f => f.team === fixtures[0].team)) {
                    loyalIds.push(id);
                    return;
                }
                if (getPlayerProblemStatus(id, playerFixtures, nominationsMap, defaultNominationDetails).isOverallProblematic) {
                     playedDownIds.push(id);
                } else if (fixtures.some((f, i) => i > 0 && getTeamRank(f.team) > getTeamRank(fixtures[i - 1].team))) {
                    playedDownIds.push(id);
                } else {
                    playedUpOnlyIds.push(id);
                }
            });

            playedDownIds.sort((a, b) => {
                const isAProblematic = getPlayerProblemStatus(a, playerFixtures, nominationsMap, defaultNominationDetails).isOverallProblematic;
                const isBProblematic = getPlayerProblemStatus(b, playerFixtures, nominationsMap, defaultNominationDetails).isOverallProblematic;
                if (isAProblematic && !isBProblematic) return -1;
                if (!isAProblematic && isBProblematic) return 1;
                return a - b;
            });

            let maxFixtures = Math.max(0, ...memberIds.map(id => playerFixtures[id].length));

            const buildTableHtml = (title, idsToRender, isGrayedOut, checkProblem) => {
                if (idsToRender.length === 0) return '';

                let tableHtml = `<div class="mb-8"><h2 class="text-2xl font-semibold text-gray-700 my-4 px-4">${title} (${idsToRender.length})</h2><div class="overflow-auto border border-gray-200 rounded-lg" style="max-height: 70vh;"><table class="min-w-full divide-y divide-gray-200">`;

                tableHtml += `<thead class="bg-gray-50"><tr>
                                <th scope="col" class="sticky top-0 left-0 z-30 px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider bg-gray-50">Member ID</th>
                                <th scope="col" class="sticky top-0 z-20 px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider bg-gray-50">Nominated Team</th>`;
                for (let i = 1; i <= maxFixtures; i++) {
                    tableHtml += `<th scope="col" class="sticky top-0 z-20 px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider bg-gray-50">Fixture ${i}</th>`;
                }
                tableHtml += `</tr></thead><tbody class="bg-white divide-y divide-gray-200">`;

                idsToRender.forEach(id => {
                    const fixtures = playerFixtures[id];
                    const rowBgClass = isGrayedOut ? 'bg-gray-100' : 'bg-white';
                    const problemStatus = checkProblem
                        ? getPlayerProblemStatus(id, playerFixtures, nominationsMap, defaultNominationDetails)
                        : { isOverallProblematic: false, problematicFixtures: [] };
                    const hasNomination = nominationsMap[id] != null;
                    const nominatedTeam = nominationsMap[id] || '';
                    const defaultNom = defaultNominationDetails[id];

                    tableHtml += `<tr>`;
                    const idBgClass = problemStatus.isOverallProblematic ? "bg-red-100" : rowBgClass;
                    const idTextClass = problemStatus.isOverallProblematic ? "text-red-700 font-bold" : (isGrayedOut ? "text-gray-500" : "text-gray-900");
                    tableHtml += `<td class="sticky left-0 z-10 px-6 py-4 whitespace-nowrap text-sm font-medium ${idBgClass} ${idTextClass}">${id}</td>`;

                    let nominatedTeamCellClass = `px-6 py-4 whitespace-nowrap text-sm ${rowBgClass}`;
                    if (hasNomination) {
                        nominatedTeamCellClass += " bg-blue-100 font-medium";
                    }
                    tableHtml += `<td class="${nominatedTeamCellClass}">${nominatedTeam}</td>`;

                    for (let i = 0; i < maxFixtures; i++) {
                        let cellClass = `px-6 py-4 whitespace-nowrap text-sm ${rowBgClass}`;
                        let cellContent = '';
                        if (fixtures[i]) {
                            cellContent = `<div>${fixtures[i].team}</div><div class="text-xs text-gray-500">${formatFixtureDate(fixtures[i].date)}</div>`;
                            if (checkProblem && problemStatus.problematicFixtures[i]) {
                                cellClass += " bg-red-100 text-red-700 font-bold";
                            }
                            if (defaultNom && fixtures[i].team === defaultNom.team && fixtures[i].date.getTime() === defaultNom.date.getTime() && !cellClass.includes('bg-red-100')) {
                                cellClass += " bg-blue-100 font-medium";
                            }
                        }
                        tableHtml += `<td class="${cellClass}">${cellContent}</td>`;
                    }
                    tableHtml += '</tr>';
                });

                tableHtml += `</tbody></table></div></div>`;
                return tableHtml;
            };

            const table1 = buildTableHtml("Players who played down", playedDownIds, false, true);
            const table2 = buildTableHtml("Players who only played up", playedUpOnlyIds, false, false);
            const table3 = buildTableHtml("Players who only played for one team", loyalIds, true, false);

            return table1 + table2 + table3;
        }
    </script>

</body>
</html>
